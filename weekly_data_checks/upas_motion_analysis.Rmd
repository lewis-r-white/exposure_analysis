---
title: "UPAS Motion Analysis"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    theme: cosmo
    toc: yes
    toc_depth: 3
    toc_float: yes
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Load Dependencies 
library(gtsummary)
library(dplyr)
library(gt)
library(ggplot2)
library(xts)
library(dygraphs)
library(plotly)
library(DT)
library(data.table)
library(tidyverse)
library(htmltools)
library(RColorBrewer)
library(lubridate)   # hour(), floor_date(), with_tz(), etc.
library(scales)      # percent_format()
library(patchwork)   # (p1 / p2) layout or wrap_plots()

```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
## PARAMETERS 
path_processed    <- here::here("weekly_data_checks","upas_data2025","processed")
move_thr          <- 0.10      # movement proportion threshold for “moving while worn”
bin_width         <- 0.10      # histogram bin width (e.g., 0.10 or 0.05)
worn_only         <- TRUE      # restrict plots to epochs marked worn
show_diag_for_all <- TRUE     # show Plot 2 for everyone (can be heavy)
night_start       <- 21        # night window start hour (21 = 9pm)
night_end         <- 5         # night window end hour (5 = 5am)
```

### Definitions

-   **seg_sec (per-row seconds):** Computed once in the reader as the median positive diff(DateTimeLocal). If not usable, falls back to PMSensorInterval, otherwise defaults to 30 s.This represents the time duration credited to each row, used to weight all time-based metrics.

-   **Run window:** `[run_start, run_start + OverallDuration hours]`. All time totals are **clipped** to `run_end` to avoid including post-run data.

-   **Worn flag** `data$worn_flag <- as.integer(data$AccelComplianceCnt > 0)`  The UPAS firmware’s AccelComplianceCnt variable (0–20) counts motion events per 30-s window.A value > 0 indicates measurable accelerometer activity and is treated as “worn.”

-    **Compliance hours (total):** The seg_sec-weighted sum of time with worn_flag == TRUE inside the run window, converted to hours.

-   **Compliance percent:** `100 × (seg_sec-weighted worn time / seg_sec-weighted total time)` within the run window.

-   **Day/Night split (local time):\
    Day** = 05:00–20:59, **Night** = 21:00–04:59.\
    (Matches your `is_day()` in the summary and `night_start = 21`, `night_end = 5` in the plots.)

-   **Sessions:**
    **S1** = 0–24 h, **S2** = 24–48 h from `run_start`.
    “Day/Night h (0–48 h)” are S1 + S2 day/night sums (still clipped to `run_end`).

-   **Orientation variables:**
    `x_vest = XDown/100` (higher ≈ worn on vest);
    `z_bed = pmax(Zup, Zdown)/100` (higher ≈ lying/bed posture)
    
    These variables are useful for visual inspection and context plots but are not used in compliance calculations.

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# files
rds_files <- list.files(path_processed, pattern = "\\.rds$", full.names = TRUE)
summaries <- list.files(path_processed, pattern = "^pm_summary_upas_.*\\.csv$", full.names = TRUE)

sum_df <- lapply(summaries, \(f) read.csv(f, check.names = FALSE)) |> bind_rows()

if (!"file" %in% names(sum_df)) sum_df$file <- as.character(sum_df$file) # if file column doesn't exist, add it so future code doesn't break
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
# Compact compliance table (uses your existing sum_df)
cols <- c(
  "community","subject_id","upas_id","start_time","end_time",
  "run_time_hour","compliance_hours","compliance_percent",
  "compliance_hours_day_session1","compliance_hours_night_session1",
  "compliance_hours_day_session2","compliance_hours_night_session2",
  "duplicate_subject"
)

comp_df <- sum_df %>%
  dplyr::select(any_of(cols)) %>%
  dplyr::mutate(
    start_time = as.POSIXct(start_time, tz = "UTC"),
    end_time   = as.POSIXct(end_time,   tz = "UTC"),
    dplyr::across(
      c(run_time_hour, compliance_hours, compliance_percent,
        compliance_hours_day_session1, compliance_hours_night_session1,
        compliance_hours_day_session2, compliance_hours_night_session2),
      ~ suppressWarnings(as.numeric(.))
    )
  )

DT::datatable(
  comp_df,
  caption   = "Compliance summary (total + day/night)",
  extensions = c("FixedColumns","FixedHeader","Buttons"),
  options = list(
    scrollX      = TRUE,
    dom          = 'Blfrtip',
    buttons      = c('copy','csv','excel'),
    fixedHeader  = TRUE,
    fixedColumns = list(leftColumns = 3)  # freeze community/subject/UPAS ID
  )
) %>%
  formatStyle('run_time_hour',                 backgroundColor = styleInterval(44, c("red","white"))) %>%
  formatStyle('compliance_hours_day_session1', backgroundColor = styleInterval(10, c("red","white"))) %>%
  formatStyle('compliance_hours_day_session2', backgroundColor = styleInterval(10, c("red","white"))) %>%
  formatStyle('compliance_hours_night_session1', backgroundColor = styleInterval(1, c("red","white"))) %>%
  formatStyle('compliance_hours_night_session2', backgroundColor = styleInterval(1, c("red","white"))) %>%
  formatStyle('duplicate_subject',            backgroundColor = styleEqual("Yes", "red"))
```

```{r, warning=FALSE, message=FALSE, echo=FALSE}
# helpers
ensure_seg_sec <- function(df){
  if (!"seg_sec" %in% names(df)) df$seg_sec <- 30
  df
}

is_night <- function(t) { h <- hour(t); (h >= night_start) | (h < night_end) }

night_rects <- function(tmin, tmax, tz = "UTC") {
  tmin <- with_tz(tmin, tz)
  tmax <- with_tz(tmax, tz)

  d0 <- floor_date(tmin, "day")
  d1 <- floor_date(tmax, "day")   # floor, not ceiling
  days <- seq(d0, d1, by = "1 day")

  rects <- tibble::tibble(
    # night block: [night_start, 24:00)
    xmin = c(days + lubridate::hours(night_start), days + lubridate::hours(0)),
    xmax = c(days + lubridate::hours(24),         days + lubridate::hours(night_end))
  )

  # Clamp to [tmin, tmax] so nothing extends the x-axis
  rects <- rects |>
    dplyr::mutate(
      xmin = pmax(xmin, tmin),
      xmax = pmin(xmax, tmax)
    ) |>
    dplyr::filter(xmax > xmin) |>
    dplyr::mutate(ymin = -Inf, ymax = Inf)

  rects
}


```



```{r, echo=FALSE, message=FALSE, warning=FALSE}
plot_accel_timeseries <- function(df, run_hours, title = NULL) {
  df <- df |>
    ensure_seg_sec() |>
    mutate(
      DateTimeLocal = as.POSIXct(DateTimeLocal, tz = "UTC"),
      AccelComplianceCnt = suppressWarnings(as.numeric(AccelComplianceCnt)),
      AccelXVar = suppressWarnings(as.numeric(AccelXVar))
    ) |>
    arrange(DateTimeLocal)

  run_start <- min(df$DateTimeLocal, na.rm = TRUE)
  run_end   <- run_start + run_hours * 3600
  df_run    <- df |> filter(DateTimeLocal <= run_end)
  rects     <- night_rects(min(df_run$DateTimeLocal), max(df_run$DateTimeLocal))

  p_cnt <- ggplot(df_run, aes(DateTimeLocal, AccelComplianceCnt)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf),
              inherit.aes = FALSE, fill = "grey70", alpha = 0.15) +
    geom_line(color = "blue", linewidth = 0.6, na.rm = TRUE) +
    labs(y = "AccelComplianceCnt", x = NULL) +
    theme_bw(base_size = 12)

  p_var <- ggplot(df_run, aes(DateTimeLocal, AccelXVar)) +
    geom_rect(data = rects, aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf),
              inherit.aes = FALSE, fill = "grey70", alpha = 0.15) +
    geom_line(color = "red", linewidth = 0.6, na.rm = TRUE) +
    labs(y = "AccelXVar", x = NULL) +
    theme_bw(base_size = 12)

  patchwork::wrap_plots(p_cnt, p_var, ncol = 1) +
    patchwork::plot_annotation(
      title = title %||% "Accelerometer activity over time",
      subtitle = "Top = AccelComplianceCnt; Bottom = AccelXVar"
    )
}

```


```{r, echo=FALSE, message=FALSE, warning=FALSE}
for (r in rds_files) {
  community <- gsub("list\\.upas_|\\d{8}\\.rds", "", basename(r))
  upas_list <- readRDS(r)
  cat(sprintf("## %s\n\n", community))

  for (df in upas_list) {
    subject <- df$subject_id[which.max(!is.na(df$subject_id))]
    if (is.na(subject)) subject <- df$UPASserial[which.max(!is.na(df$UPASserial))]

    run_h <- if ("OverallDuration" %in% names(df))
      as.numeric(df$OverallDuration[1])
    else
      as.numeric(difftime(max(df$DateTimeLocal, na.rm = TRUE),
                          min(df$DateTimeLocal, na.rm = TRUE),
                          units = "hours"))

    run_h <- ifelse(is.finite(run_h) && run_h > 0, run_h, 48)

    print(plot_accel_timeseries(df, run_h, title = paste("Subject:", subject)))
  }
}
```









